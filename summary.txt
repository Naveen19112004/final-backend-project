npm i mongoose
âœ… It installs Mongoose into your project, so you can:
Connect your app to a MongoDB database
Define schemas and models
Perform database operations (like save, find, update, delete) in a structured way
ðŸ§  Why use Mongoose?
Without Mongoose,
db.collection('users').insertOne({ name: "Naveen", age: 22 });
with mongoose
const user = new User({ name: "Naveen", age: 22 });
await user.save();

user.model.js ->standard practise
import mongoose from 'mongoose';
const UserSchema=new mongoose.Schema({
    username:String,
    email:String,
    isActive:Bolean
})
//latest
const UserSchema=new mongoose.Schema({
    {
        username:{
            type:String,
            requried:true,
            unique:true,
            lowercase:true
        },
        email:{
            type:Strin,g
            required:true,
            unique:true,
            lowercase:true
        },
        password:{
            type:String,
            required:[true,"password is req"]
        }
    }
},{timestamps:true}
);
// this schema is created on inside the mongoDB
if we are not exporting it creation of schema doesnot work
//export const User=mongoose.model("User",userScehma) 
mongoose.mode("which model",on which basis we need to make model)



import mongoose from 'mongoose';
const todoschema=new monngoose.Schema({
content:{
    type:String,
    required:true,

},
complete:{
    type:Boolean,
    default:false
},
createdBy:{
    type:mongoose.Schema.Types.ObjectId,
    ref:"User"
}
subTodos:[
    {
    type:mongoose.Schema.Types.ObjectId,
    ref:"subtodos"
}],//arrray of subtodos
})
export const Todo=mongoose.model("Todo",todoschema)


import mongoose from 'mongoose';
const subtodos=new mongoose.Schema({
    content:{
        type:Stringg,
        required:true,

    },
    complete:{
        type:Boolean,
        default:false
    }
    createdByy:{
        type:mongoose.Schema.Types.ObjectId,
        ref:"User"
    }
},timestamps:true)
export const SubTodo=mongoose.model("Subtodo",subtodos)


real time project started here
new repository in git final-backend-project
npm init

here i added puclic folder inside thst temp folder also 
now i tried using [git status-> it shows there are no change to commit ]

then i created .gitkeep file inside the temp folder then git status 
then it shows that you need to commit some file public folder 
actually keeping the track of empty folder is useless and when i added file to it ,it shows on the git ststus to be commited

creating .gitnore just ouside the publicnfoder
there are some files to be ignored to push into the git ,
for that there gitignore generator in the google
search gitignore generator->gitignore.io->node->copy->paste

now create .env file->environment variables are picked up fromthe systems so
thst they are secure,they are not picked up from the file,
so as soon as ur code goes to production,there also on those services you get the fields of env variables

so if you push .env to git hub ,it gives you error(warning),
so we create .env.sample file
whatever work done by.env will also done by .env.sample for just to gve it github as that file is not added to .gitignore file

now inside root one more folder
src 
whatever work we have or whhatever our files are, we will keep them inside that,
now when we go inside the source,we will need2-3 files,that is
easiest to cretae these files is that ,u can by right clicking
app.js
constants.js
index.js

and i need to update te package.json filelike to import the files we have 2 types in backend'
1. requrie syntax
2. import (module)

nodemon
to restart the server
go to package.json file and modify
"test": "echo \"Error: no test specified\" && exit 1" this to
"dev": "nodemon src/index.js"
When you add this in your package.json:
"scripts": {
  "dev": "nodemon index.js"
}
Youâ€™re telling npm:
"Whenever someone runs npm run dev, execute the command nodemon index.js."
So now, instead of manually typing:
nodemon index.js
You just type:
npm run dev
And npm runs that command for you, as defined in the "scripts" section.

one problem here is that.env uses the require syntax we have solution for this as well,we will discuss
and we used type:module in package.json
