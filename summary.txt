npm i mongoose
âœ… It installs Mongoose into your project, so you can:
Connect your app to a MongoDB database
Define schemas and models
Perform database operations (like save, find, update, delete) in a structured way
ðŸ§  Why use Mongoose?
Without Mongoose,
db.collection('users').insertOne({ name: "Naveen", age: 22 });
with mongoose
const user = new User({ name: "Naveen", age: 22 });
await user.save();

user.model.js ->standard practise
import mongoose from 'mongoose';
const UserSchema=new mongoose.Schema({
    username:String,
    email:String,
    isActive:Bolean
})
//latest
const UserSchema=new mongoose.Schema({
    {
        username:{
            type:String,
            requried:true,
            unique:true,
            lowercase:true
        },
        email:{
            type:Strin,g
            required:true,
            unique:true,
            lowercase:true
        },
        password:{
            type:String,
            required:[true,"password is req"]
        }
    }
},{timestamps:true}
);
// this schema is created on inside the mongoDB
if we are not exporting it creation of schema doesnot work
//export const User=mongoose.model("User",userScehma) 
mongoose.mode("which model",on which basis we need to make model)



import mongoose from 'mongoose';
const todoschema=new monngoose.Schema({
content:{
    type:String,
    required:true,

},
complete:{
    type:Boolean,
    default:false
},
createdBy:{
    type:mongoose.Schema.Types.ObjectId,
    ref:"User"
}
subTodos:[
    {
    type:mongoose.Schema.Types.ObjectId,
    ref:"subtodos"
}],//arrray of subtodos
})
export const Todo=mongoose.model("Todo",todoschema)


import mongoose from 'mongoose';
const subtodos=new mongoose.Schema({
    content:{
        type:Stringg,
        required:true,

    },
    complete:{
        type:Boolean,
        default:false
    }
    createdByy:{
        type:mongoose.Schema.Types.ObjectId,
        ref:"User"
    }
},timestamps:true)
export const SubTodo=mongoose.model("Subtodo",subtodos)


real time project started here
new repository in git final-backend-project
npm init

here i added puclic folder inside thst temp folder also 
now i tried using [git status-> it shows there are no change to commit ]

then i created .gitkeep file inside the temp folder then git status 
then it shows that you need to commit some file public folder 
actually keeping the track of empty folder is useless and when i added file to it ,it shows on the git ststus to be commited

creating .gitnore just ouside the publicnfoder
there are some files to be ignored to push into the git ,
for that there gitignore generator in the google
search gitignore generator->gitignore.io->node->copy->paste

now create .env file->environment variables are picked up fromthe systems so
thst they are secure,they are not picked up from the file,
so as soon as ur code goes to production,there also on those services you get the fields of env variables

so if you push .env to git hub ,it gives you error(warning),
so we create .env.sample file
whatever work done by.env will also done by .env.sample for just to gve it github as that file is not added to .gitignore file

now inside root one more folder
src 
whatever work we have or whhatever our files are, we will keep them inside that,
now when we go inside the source,we will need2-3 files,that is
easiest to cretae these files is that ,u can by right clicking
app.js
constants.js
index.js

and i need to update te package.json filelike to import the files we have 2 types in backend'
1. requrie syntax
2. import (module)

nodemon
to restart the server
go to package.json file and modify
"test": "echo \"Error: no test specified\" && exit 1" this to
"dev": "nodemon src/index.js"
When you add this in your package.json:
"scripts": {
  "dev": "nodemon index.js"
}
Youâ€™re telling npm:
"Whenever someone runs npm run dev, execute the command nodemon index.js."
So now, instead of manually typing:
nodemon index.js
You just type:
npm run dev
And npm runs that command for you, as defined in the "scripts" section.

one problem here is that.env uses the require syntax we have solution for this as well,we will discuss
and we used type:module in package.json

now create controllers ,db,routes,models,utils files in the src folder

now npm i _D prettier
create file .prettierrc in root dir
.prettierignore also to ignore the files which should not use prettier

âœ… What is Prettier?
Prettier is a code formatter that:
Automatically formats your code
Enforces consistent style (indentation, spacing, quotes, semicolons, etc.)
Removes unnecessary code clutter (e.g., extra spaces, bad indentation)

What is .prettierrc?
Itâ€™s a configuration file (usually in JSON format) where you define how Prettier should format your code project-wide.

âœ… Why create .prettierrc in the root?
Customizes formatting rules for your project
For example, you can define:
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2
}
This makes sure:
Every statement ends with a semicolon
Single quotes are used instead of double
Tabs are 2 spaces wide

.prettierignore	Tells Prettier which files to skip
 Example .prettierignore file:
plaintext
node_modules
dist
build
package-lock.json
.env
coverage
*.min.js
public/*
This tells Prettier:
Don't format any files or folders listed here.
Patterns (like *.min.js) also work.
 What is .prettierignore?
Just like .gitignore, the .prettierignore file tells Prettier to ignore certain files or folders â€” it will not format anything you list here.

connecting db 
google search ->mongodb atlas->MongoDB Atlas | The Modern, Multi-Cloud Database
sign in->create project->project-name(my-project)->free select->aws->cluster0->create deployment->what will it do,mongodb behind the scenes is going to aws and ur
db will be there,all its softwares,whatever is the req,the connections string that needs to be created,all of them will b created automatically
all that has been created ,now we need a connection,so mongodb has been created it, ialso want to connect it to the database
so for that ,a username and password will be required so give them there->crete 
then go to network access
to enter into the mongodb we have 2 formats
1.ip address should be allowed so that you can accee=ss
2.or you should have correct id password
3.one should have url

so add ip address 
go to network access->add ip address
if our app is running on aws or digital ocean then in the production grade settings,we never allow acess from anywhere ,in some cases if it has to be done for testing 
or if w e want to see smthg ,then we will allow some ips.It
i choosed allow acess from any as it is my acc
acess entry:0.0.0.0/0 comment:allow all acess:CAUTION

db access
create username and pass 
naveen
Nn11@gmail.com
readandwrite any db and crete it
 and now i go db inside
 for coneccting db we have diffrent options
 1. we go with the string url given int he compass ->copy that->
 for connecting db 
 first go to .env file
 update PORT=8000
 MONGO_URI=mongodb+srv://naveen:Nn11@gmail.com@cluster0.bdlolow.mongodb.net/
 i am pasting it in env.sample file also by the time you see it i ll change the all the things so you can acess it
 

 now going to constants.js and wtite export const DB_NAME="videotube"
 this isnot the system relate var but it belongs to the applicatiopn variable that is reason i hav eput it in constats

 db connection can be done in2 to 3 wways
 2 major
 1.one approach is that what should we do is that all the code 
we are going to execute the index file first through node or nodemon through 
so i keep all my code in index file so as soon as index file is loaded,the code of db connection in the function that i have written ,i shouldget 
it exuxexcuted immediately
2.i will create a folder in the name of DB and write my function of connection inside it and then import that func in myindex and get it executed there
we follw 2nd one
how to connect
app->express ke through
db connection->mongoose ke throough
 can db connect in one line 
 yes ,but that is not the professional approach

 we take firdst approach now,
 open index.js
 import mongoose from 'mongoose';
 import {DB_NAME} from "./constants";
 import express from "express";
 const app=express();
 function DBconnet(){}
 DBconnect()
 there is nothing wrong in this app but not professional
 ()()->IIFE concept in js
 (async()=>{
    try{
        await mongoose.connect(`${process.env.MONGODB_URI }/${DB_NAME}`)
        app.on(("error"),(error)=>{
            console.log("ERR");
            throw error
        }
        )
        app.listen(process.env.PORT,()=>{
            console.log(`APP is listening on the port ${process.env.PORT}`)
        })
    }
    catch(error){
        console.error("ERROR: "error)
        throw err
    }
 })()

 ðŸ§© But what is this part for?
ðŸ”¹ app.on("error", ...)
This listens for Express app errors â€” like if something goes wrong while handling a request or starting the server.
This is not related to MongoDB.
It's optional, but useful for catching runtime issues in the Express server.
ðŸ”¹ app.listen(...)
This is the part that starts your Express server.
ðŸ’¡ So, your app won't respond to any HTTP request (like GET /, POST /login) unless you call app.listen(...).

ðŸ“Š So why are both used together?
Because in a real application, you want to:
Connect to the database
Only start the server if the DB connection is successful
Handle app-level errors gracefully
âœ… Real-Life Analogy:
Imagine you're opening a restaurant:
mongoose.connect(...) = Getting your kitchen ready (connecting to DB)
app.listen(...) = Opening the front door for customers (start the server)
app.on("error") = Being ready if something goes wrong in the restaurant (e.g. power cut, customer issue)
 

 this is the first app

 for the second app
 i am creating index.js in db folder which is under src folder
 import mongoose fom 'mongoose';
 import {DB_NAME} from "./constants";
 import connectDB from "./db/index";
 require('dotenv').config({path:'./env'}) or import dotenv form"dotenv" then dotenv.config({
    path:'./env'
 })
 //db in another continent he is sayning y>
 const connectDB=async(=>{
    try{
    const connectionINStance= awiat mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`)
    console.log(`\n MOngo connected! DB HOST:${connectionInstance.connection.host});
    }
    catch(error){
        console.log("monddb coneccction error",errr);
        process.exit(1); 
    }
 })
 export default connectDB

 so now i can directly write import connectDB from "./db"
 connectDB( )

 connection to db is done
9 th lecture
 now open app.js
 import express from 'express'
 const app=express();
 request params.whenvere any data comes from the url,it mostly
 comes from request params called params
 many times we see inside the url ,there is ?,search equals and then any term,we understan
 d how all those parameters are handled
 in requestt params you will find one req body,so what
is in the req body, the data can come in diffreernt wwayscan come from in froms,it can come
in json ,so for that also we have to do some activites
one thing is that sometimes you will also get  
data from cookies. 
ins cookie-parser?
why and all we discuss 
and also cors ->app.use
whenever you are using middleware,most of the time you do it through app.use
npm install cookie-parser cors
so import thenm in app.js
import express from 'express'
import cors from "cors";
import cookieParser from "cookie-parser";
const app=express();
export {app} 
if we want to import cookie-parser 
 app.use(cors({
    origin:process.env.CORS_ORIGIN,
    credentials:true;
 }))
 in .env
 CORS_ORIGIN=* which means ,req coming from anywhere will be accepted obviously
 like from vercel ,someone else

 app.use->configuration i need to set ->middle ware ineed to set
 y?those has to be done
 what is middleware?
 with express u can directly configure json in such a way that
 i am acceting json by app.use(express.json())
 further options inside that is limit i.e howmuch limit that you want to use
 app.use(express.json({limit:"16kb"}))
 earlier express not able accept our json files
 there you have to use body parser to accept those files


 when we filll the form ,then we took the dat,now i have to configure
 one more thing that when i geet  the data from the url thattoo is required 
 now when the data comes from the url then there is  a issue,
 like in our link smthg will be added like %20 smthg like that 
 all this also has to be told to the express that look the data will come
 from there also ,so please uns=derstand that,
 a configuration has to be done for that so i have to use app.use(express.urlencoded({
    extended:true;,limit:"16kb"
 }))
 final configuration is
 app.use(express.static)//files,folders,pdf stores
 if i want to store them in my own  server then i create a public folder
 and some public assests which anyone can access them
 name is publisc so
 app.use(express.static("public"))
 one thing we have not done yet 
 cookie-parser?
 its work is just that i can acess the cookies in the
 users browser from my server and also be able to set its cookies,
 so basically i can do crud operations
 so app.use(cookieParser())
 middleware?
 for example if the client accesing or hit the url /instgram
 if someone comes to this url ,i say iot it that what it should happen
 that is (req,res) res.send("hitesh")
 first a url req came to means
 and handled it and sent it but i want to get some process
 done because a lot of requests will come on the url,you are capable
 of receiving that response or not,it may be that you
have not logged in ,so someone has to check has to be done in between ,that checking in between 
is called middleware
(err,req,res,next)
here next is mw which is a flag that look my work
is done,now go to next so it will go to this
it is also necessary to use next becaue if there is no flag how wie will pass to next


so now we make utility foder in that we creare a he;per fn which heps to deal with try catck api error handling 
\


9th Lecture Notes: Express App Setup, Middleware, and Request Handling
1. Opening app.js and setting up Express
js
Copy
Edit
import express from 'express';
const app = express();
2. Request Params and Request Body
Request params: Whenever any data comes from the URL, it mostly comes through request params, accessible via req.params.

Many times, inside the URL, we see queries like ?search=term. These are query parameters and can be accessed using req.query.

In request params, you will also find req.body.

3. What is in req.body?
Data can come in different ways:

From forms (usually URL-encoded)

From JSON payloads

To handle these properly, Express requires middleware configuration (explained below).

4. Data from Cookies
Sometimes you will get data from cookies.

To work with cookies in Express, we use the cookie-parser package.

Cookie-parser allows you to read cookies from the user's browser and also set cookies via your server.

This enables CRUD operations on cookies.

5. CORS (Cross-Origin Resource Sharing)
When the frontend and backend are on different origins (domains, ports, etc.), CORS issues occur.

To handle CORS, use the cors middleware.

Example:

js
Copy
Edit
app.use(cors({
  origin: process.env.CORS_ORIGIN,
  credentials: true,
}));
In .env file, CORS_ORIGIN=* means requests from anywhere will be accepted (use carefully in production).

6. Middleware and app.use()
Middleware is a function that runs between the request and the response.

Most middleware is set up using app.use().

For example, to parse JSON in incoming requests:

js
Copy
Edit
app.use(express.json());
You can configure middleware further with options:

js
Copy
Edit
app.use(express.json({ limit: "16kb" }));
Earlier versions of Express could not parse JSON directly; they required a separate package called body-parser.

7. Handling URL-Encoded Data (Forms)
When forms send data, itâ€™s usually URL-encoded.

Express needs to be configured to parse this:

js
Copy
Edit
app.use(express.urlencoded({
  extended: true,
  limit: "16kb"
}));
The option extended: true allows for rich objects and arrays to be encoded into the URL-encoded format.

8. Serving Static Files
If you want to serve files like images, PDFs, or other public assets from your own server, create a folder called public.

Use Express middleware to serve files from that folder:

js
Copy
Edit
app.use(express.static("public"));
Files in public become accessible publicly via URLs.

9. Using cookie-parser
To work with cookies in Express, import and use the middleware:

js
Copy
Edit
import cookieParser from 'cookie-parser';
app.use(cookieParser());
This middleware parses cookies attached to the client request object, making it easy to read and set cookies.

10. What is Middleware?
Middleware functions can process requests before they reach the route handler.

Example: If a client accesses /instagram, middleware can check if the user is logged in.

Signature:

js
Copy
Edit
(req, res, next) => { /* ... */ }
next() is a flag to pass control to the next middleware or route handler.

Without calling next(), the request will not proceed further and may hang.

11. Middleware with Error Handling
Error-handling middleware has this signature:

js
Copy
Edit
(err, req, res, next) => { /* ... */ }
Use next(err) to pass errors to error middleware.

Middleware can be stacked in sequence to handle multiple tasks like authentication, logging, etc.

12. Practical Example of Middleware Flow
Client sends request â†’ Middleware 1 runs â†’ Middleware 2 runs â†’ Route handler runs â†’ Response sent

Middleware can intercept requests for:

Authentication

Logging

Validation

Error handling

13. Utility Folder and Helper Function
To handle API errors in a clean way, create a utility folder.

Inside it, create a helper function for try-catch error handling in async functions.

This prevents code repetition and helps centralize error management.

 Additional Points:
Always keep your middleware order in mind. For example, cors() and cookie-parser() should come before route handlers.
Use environment variables to configure origins and sensitive settings.
Limit request size to avoid denial of service attacks via large payloads.
Use HTTPS in production to secure cookies and data.

