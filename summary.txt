npm i mongoose
âœ… It installs Mongoose into your project, so you can:
Connect your app to a MongoDB database
Define schemas and models
Perform database operations (like save, find, update, delete) in a structured way
ðŸ§  Why use Mongoose?
Without Mongoose,
db.collection('users').insertOne({ name: "Naveen", age: 22 });
with mongoose
const user = new User({ name: "Naveen", age: 22 });
await user.save();

user.model.js ->standard practise
import mongoose from 'mongoose';
const UserSchema=new mongoose.Schema({
    username:String,
    email:String,
    isActive:Bolean
})
//latest
const UserSchema=new mongoose.Schema({
    {
        username:{
            type:String,
            requried:true,
            unique:true,
            lowercase:true
        },
        email:{
            type:Strin,g
            required:true,
            unique:true,
            lowercase:true
        },
        password:{
            type:String,
            required:[true,"password is req"]
        }
    }
},{timestamps:true}
);
// this schema is created on inside the mongoDB
if we are not exporting it creation of schema doesnot work
//export const User=mongoose.model("User",userScehma) 
mongoose.mode("which model",on which basis we need to make model)



import mongoose from 'mongoose';
const todoschema=new monngoose.Schema({
content:{
    type:String,
    required:true,

},
complete:{
    type:Boolean,
    default:false
},
createdBy:{
    type:mongoose.Schema.Types.ObjectId,
    ref:"User"
}
subTodos:[
    {
    type:mongoose.Schema.Types.ObjectId,
    ref:"subtodos"
}],//arrray of subtodos
})
export const Todo=mongoose.model("Todo",todoschema)


import mongoose from 'mongoose';
const subtodos=new mongoose.Schema({
    content:{
        type:Stringg,
        required:true,

    },
    complete:{
        type:Boolean,
        default:false
    }
    createdByy:{
        type:mongoose.Schema.Types.ObjectId,
        ref:"User"
    }
},timestamps:true)
export const SubTodo=mongoose.model("Subtodo",subtodos)


real time project started here
new repository in git final-backend-project
npm init

here i added puclic folder inside thst temp folder also 
now i tried using [git status-> it shows there are no change to commit ]

then i created .gitkeep file inside the temp folder then git status 
then it shows that you need to commit some file public folder 
actually keeping the track of empty folder is useless and when i added file to it ,it shows on the git ststus to be commited

creating .gitnore just ouside the publicnfoder
there are some files to be ignored to push into the git ,
for that there gitignore generator in the google
search gitignore generator->gitignore.io->node->copy->paste

now create .env file->environment variables are picked up fromthe systems so
thst they are secure,they are not picked up from the file,
so as soon as ur code goes to production,there also on those services you get the fields of env variables

so if you push .env to git hub ,it gives you error(warning),
so we create .env.sample file
whatever work done by.env will also done by .env.sample for just to gve it github as that file is not added to .gitignore file

now inside root one more folder
src 
whatever work we have or whhatever our files are, we will keep them inside that,
now when we go inside the source,we will need2-3 files,that is
easiest to cretae these files is that ,u can by right clicking
app.js
constants.js
index.js

and i need to update te package.json filelike to import the files we have 2 types in backend'
1. requrie syntax
2. import (module)

nodemon
to restart the server
go to package.json file and modify
"test": "echo \"Error: no test specified\" && exit 1" this to
"dev": "nodemon src/index.js"
When you add this in your package.json:
"scripts": {
  "dev": "nodemon index.js"
}
Youâ€™re telling npm:
"Whenever someone runs npm run dev, execute the command nodemon index.js."
So now, instead of manually typing:
nodemon index.js
You just type:
npm run dev
And npm runs that command for you, as defined in the "scripts" section.

one problem here is that.env uses the require syntax we have solution for this as well,we will discuss
and we used type:module in package.json

now create controllers ,db,routes,models,utils files in the src folder

now npm i _D prettier
create file .prettierrc in root dir
.prettierignore also to ignore the files which should not use prettier

âœ… What is Prettier?
Prettier is a code formatter that:
Automatically formats your code
Enforces consistent style (indentation, spacing, quotes, semicolons, etc.)
Removes unnecessary code clutter (e.g., extra spaces, bad indentation)

What is .prettierrc?
Itâ€™s a configuration file (usually in JSON format) where you define how Prettier should format your code project-wide.

âœ… Why create .prettierrc in the root?
Customizes formatting rules for your project
For example, you can define:
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2
}
This makes sure:
Every statement ends with a semicolon
Single quotes are used instead of double
Tabs are 2 spaces wide

.prettierignore	Tells Prettier which files to skip
 Example .prettierignore file:
plaintext
node_modules
dist
build
package-lock.json
.env
coverage
*.min.js
public/*
This tells Prettier:
Don't format any files or folders listed here.
Patterns (like *.min.js) also work.
 What is .prettierignore?
Just like .gitignore, the .prettierignore file tells Prettier to ignore certain files or folders â€” it will not format anything you list here.

connecting db 
google search ->mongodb atlas->MongoDB Atlas | The Modern, Multi-Cloud Database
sign in->create project->project-name(my-project)->free select->aws->cluster0->create deployment->what will it do,mongodb behind the scenes is going to aws and ur
db will be there,all its softwares,whatever is the req,the connections string that needs to be created,all of them will b created automatically
all that has been created ,now we need a connection,so mongodb has been created it, ialso want to connect it to the database
so for that ,a username and password will be required so give them there->crete 
then go to network access
to enter into the mongodb we have 2 formats
1.ip address should be allowed so that you can accee=ss
2.or you should have correct id password
3.one should have url

so add ip address 
go to network access->add ip address
if our app is running on aws or digital ocean then in the production grade settings,we never allow acess from anywhere ,in some cases if it has to be done for testing 
or if w e want to see smthg ,then we will allow some ips.It
i choosed allow acess from any as it is my acc
acess entry:0.0.0.0/0 comment:allow all acess:CAUTION

db access
create username and pass 
naveen
Nn11@gmail.com
readandwrite any db and crete it
 and now i go db inside
 for coneccting db we have diffrent options
 1. we go with the string url given int he compass ->copy that->
 for connecting db 
 first go to .env file
 update PORT=8000
 MONGO_URI=mongodb+srv://naveen:Nn11@gmail.com@cluster0.bdlolow.mongodb.net/
 i am pasting it in env.sample file also by the time you see it i ll change the all the things so you can acess it
 

 now going to constants.js and wtite export const DB_NAME="videotube"
 this isnot the system relate var but it belongs to the applicatiopn variable that is reason i hav eput it in constats

 db connection can be done in2 to 3 wways
 2 major
 1.one approach is that what should we do is that all the code 
we are going to execute the index file first through node or nodemon through 
so i keep all my code in index file so as soon as index file is loaded,the code of db connection in the function that i have written ,i shouldget 
it exuxexcuted immediately
2.i will create a folder in the name of DB and write my function of connection inside it and then import that func in myindex and get it executed there
we follw 2nd one
how to connect
app->express ke through
db connection->mongoose ke throough
 can db connect in one line 
 yes ,but that is not the professional approach

 we take firdst approach now,
 open index.js
 import mongoose from 'mongoose';
 import {DB_NAME} from "./constants";
 import express from "express";
 const app=express();
 function DBconnet(){}
 DBconnect()
 there is nothing wrong in this app but not professional
 ()()->IIFE concept in js
 (async()=>{
    try{
        await mongoose.connect(`${process.env.MONGODB_URI }/${DB_NAME}`)
        app.on(("error"),(error)=>{
            console.log("ERR");
            throw error
        }
        )
        app.listen(process.env.PORT,()=>{
            console.log(`APP is listening on the port ${process.env.PORT}`)
        })
    }
    catch(error){
        console.error("ERROR: "error)
        throw err
    }
 })()

 ðŸ§© But what is this part for?
ðŸ”¹ app.on("error", ...)
This listens for Express app errors â€” like if something goes wrong while handling a request or starting the server.
This is not related to MongoDB.
It's optional, but useful for catching runtime issues in the Express server.
ðŸ”¹ app.listen(...)
This is the part that starts your Express server.
ðŸ’¡ So, your app won't respond to any HTTP request (like GET /, POST /login) unless you call app.listen(...).

ðŸ“Š So why are both used together?
Because in a real application, you want to:
Connect to the database
Only start the server if the DB connection is successful
Handle app-level errors gracefully
âœ… Real-Life Analogy:
Imagine you're opening a restaurant:
mongoose.connect(...) = Getting your kitchen ready (connecting to DB)
app.listen(...) = Opening the front door for customers (start the server)
app.on("error") = Being ready if something goes wrong in the restaurant (e.g. power cut, customer issue)
 

 this is the first app

 for the second app
 i am creating index.js in db folder which is under src folder
 import mongoose fom 'mongoose';
 import {DB_NAME} from "./constants";
 import connectDB from "./db/index";
 require('dotenv').config({path:'./env'}) or import dotenv form"dotenv" then dotenv.config({
    path:'./env'
 })
 //db in another continent he is sayning y>
 const connectDB=async(=>{
    try{
    const connectionINStance= awiat mongoose.connect(`${process.env.MONGODB_URI}/${DB_NAME}`)
    console.log(`\n MOngo connected! DB HOST:${connectionInstance.connection.host});
    }
    catch(error){
        console.log("monddb coneccction error",errr);
        process.exit(1); 
    }
 })
 export default connectDB

 so now i can directly write import connectDB from "./db"
 connectDB( )